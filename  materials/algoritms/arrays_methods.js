arr = [1, 2, 4, 5, 2, 91, 23, 123, 5, 2, 3];

// ADD and DELETE elements
arr.push(1) // – добавляет элементы в конец,
arr.pop() // – извлекает элемент из конца,
arr.shift() // – извлекает элемент из начала,
arr.unshift(5) // – добавляет элементы в начало.

// DELETE splice
arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
// удалить 2 первых элемента и результат массива присвоить в переменную
let removed = arr.splice(0, 2);

// SLICE
// Он возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end)
arr.slice(1, 3); // e,s (копирует с 1 до 3)
arr.slice(-2); // s,t (копирует с -2 до конца)

// CONCAT
// Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения
// создать массив из: arr и [3,4]
arr.concat([3, 4]); // ...arr,3,4

// forEach
arr.forEach(function (item, index, array) {
    // ... делать что-то с item
});

// Array find
// indexOf/lastIndexOf и includes
let item = ''
let from = ''
arr.indexOf(item, from) // ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент, в противном случае -1.
arr.lastIndexOf(item, from) // – то же самое, но ищет справа налево.
arr.includes(item, from) // – ищет item, начиная с индекса from, и возвращает true, если поиск успешен.

let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // Вася
// Метод arr.findIndex – по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и -1, если ничего не найдено.

// Шпаргалка по методам массива:
//
// Для добавления/удаления элементов:
// push (...items) – добавляет элементы в конец,
// pop() – извлекает элемент с конца,
// shift() – извлекает элемент с начала,
// unshift(...items) – добавляет элементы в начало.
// splice(pos, deleteCount, ...items) – начиная с индекса pos, удаляет deleteCount элементов и вставляет items.
// slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).
// concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.
// func(item, index, array){}
// Для поиска среди элементов:
// indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
// includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
// find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
// findIndex похож на find, но возвращает индекс вместо значения.
//
// Для перебора элементов:
// forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.
//
// Для преобразования массива:
// map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
// sort(func) – сортирует массив «на месте», а потом возвращает его.
// reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
// split/join – преобразует строку в массив и обратно.
// reduce(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.
//
// Дополнительно:
// Array.isArray(arr) проверяет, является ли arr массивом.
//
// Обратите внимание, что методы sort, reverse и splice изменяют исходный массив.
//
// Изученных нами методов достаточно в 99% случаев, но существуют и другие.
//
// arr.some(fn)/arr.every(fn) проверяет массив.
//
// Функция fn вызывается для каждого элемента массива аналогично map. Если какие-либо/все результаты вызовов являются true, то метод возвращает true, иначе false.
//
// arr.fill(value, start, end) – заполняет массив повторяющимися value, начиная с индекса start до end.
//
// arr.copyWithin(target, start, end) – копирует свои элементы, начиная со start и заканчивая end, в собственную позицию target (перезаписывает существующие).


// Факториал
// 1
function fact(n) {
    return n != 1 ? n * fact(--n) : 1
}

result = fact(5)
// 2
let acc = 1

function fact(n) {
    acc *= n
    if (n === 1) return
    fact(--n)
    return acc
}

result = fact(5)


console.log(arr)
